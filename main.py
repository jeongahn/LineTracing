from time import sleepimport ultraModule as ulimport RPi.GPIO as GPIOimport TurnModuleGPIO.setmode(GPIO.BOARD)MotorLeft_A = 12MotorLeft_B = 11MotorLeft_PWM = 35MotorRight_A = 15MotorRight_B = 13MotorRight_PWM = 37GPIO.setup(MotorLeft_A, GPIO.OUT)GPIO.setup(MotorLeft_B, GPIO.OUT)GPIO.setup(MotorLeft_PWM, GPIO.OUT)GPIO.setup(MotorRight_A, GPIO.OUT)GPIO.setup(MotorRight_B, GPIO.OUT)GPIO.setup(MotorRight_PWM, GPIO.OUT)GPIO.output(MotorLeft_A, GPIO.LOW)GPIO.output(MotorLeft_B, GPIO.HIGH)GPIO.output(MotorLeft_PWM, GPIO.HIGH)GPIO.output(MotorRight_A, GPIO.HIGH)GPIO.output(MotorRight_B, GPIO.LOW)GPIO.output(MotorRight_PWM, GPIO.HIGH)LeftPwm = GPIO.PWM(MotorLeft_PWM, 100)RightPwm = GPIO.PWM(MotorRight_PWM, 100)# sensor initleftmostled = 16leftlessled = 18centerled = 22rightlessled = 40rightmostled = 32GPIO.setup(leftmostled, GPIO.IN)GPIO.setup(leftlessled, GPIO.IN)GPIO.setup(centerled, GPIO.IN)GPIO.setup(rightlessled, GPIO.IN)GPIO.setup(rightmostled, GPIO.IN)# core codedef go(leftSpeed, rightSpeed):    LeftPwm.start(leftSpeed * 2.4)    RightPwm.start(rightSpeed * 2.4)# sleep(0.0001)def stop():    LeftPwm.ChangeDutyCycle(0)    RightPwm.ChangeDutyCycle(0)check = Falsego(0, 0)result = [    ['01111', 26, 8, 1],    ['00111', 20, 9, 1],    ['00011', 23, 10.5, 1],    ['10111', 23, 11, 1],    ['10011', 23, 16, 1],    ['11110', 8, 29, -1],    ['11100', 9, 25, -1],    ['11000', 10.5, 25, -1],    ['11101', 11, 25, -1],    ['11001', 16, 25, -1],    ['11011', 22, 22, -1],    ['10001', 22, 22, -1],]direction = 0loop = 0avoid_check = Falsemaze_check = Falseold_sensor = ["1","1","1","1","1"]old_check = Falseturn_left = 48turn_right = 48try:    while True:                sensor = [            str(GPIO.input(leftmostled)),            str(GPIO.input(leftlessled)),            str(GPIO.input(centerled)),            str(GPIO.input(rightlessled)),            str(GPIO.input(rightmostled))        ]        print(sensor)	        if old_check and sensor[4] =="1"  and sensor[3] == "1" and not avoid_check and not maze_check:	    old_check=False	    go(18,18)	    sleep(0.3)            TurnModule.rightPointTurn(43)	    print("right")            maze_check = True            old_sensor = ["1","1","1","1","1"]	    direction = 1	                GPIO.output(MotorLeft_PWM, GPIO.HIGH)            GPIO.output(MotorRight_PWM, GPIO.HIGH)	    while True:		temp_sensor = [            		str(GPIO.input(leftmostled)),            		str(GPIO.input(leftlessled)),            		str(GPIO.input(centerled)),            		str(GPIO.input(rightlessled)),            		str(GPIO.input(rightmostled))        	]		print("right:",temp_sensor)		if "".join(temp_sensor) == "11111":			break		sleep(0.05)	    continue	elif not old_check and sensor[4] == "0" and sensor[3] == "0":		old_check = True        	if "".join(sensor) == "11111" and not maze_check and not avoid_check:            print("error")	    go(18,18)	    sleep(0.2)            if direction == -1:                TurnModule.rightPointTurn(48)		direction = 1            elif direction == 1:                TurnModule.leftPointTurn(48)		direction = -1            avoid_check = True            GPIO.output(MotorLeft_PWM, GPIO.HIGH)            GPIO.output(MotorRight_PWM, GPIO.HIGH)                        continue	elif "".join(sensor) == "11111" and (maze_check or avoid_check):		while True:			temp_check=False			temp_sensor = [        	                str(GPIO.input(leftmostled)),                	        str(GPIO.input(leftlessled)),                        	str(GPIO.input(centerled)),                       	 	str(GPIO.input(rightlessled)),                        	str(GPIO.input(rightmostled))	                ]			for i in temp_sensor:				if i == "0":					temp_check=True					break			if temp_check:				break			stop()			sleep(0.3)			if direction == -1:				TurnModule.leftPointTurn(48)			elif direction == 1:				TurnModule.rightPointTurn(48)			sleep(0.2)	inputStream = "".join(sensor)        for idx in range(len(result)):            if inputStream == result[idx][0]:		if not avoid_check or not maze_check:			old_check = False                avoid_check = False		maze_check = False                TurnModule.leftmotor(False)                TurnModule.rightmotor(False)                print(result[idx])                go(result[idx][2], result[idx][1])                direction = result[idx][3]                break        old_sensor = sensor        sleep(0.05)except KeyboardInterrupt:    GPIO.output(MotorLeft_PWM, GPIO.LOW)    GPIO.output(MotorRight_PWM, GPIO.LOW)    LeftPwm.ChangeDutyCycle(0)    RightPwm.ChangeDutyCycle(0)    GPIO.cleanup()